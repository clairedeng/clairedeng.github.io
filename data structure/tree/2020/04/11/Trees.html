<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="shortcut icon" href="/static/img/favicon.ico" />
    <title>Trees - Study Notes</title>
    <meta name="author" content="Claire Deng" />
    <meta name="description" content="Trees" />
    <meta name="keywords" content="Trees, Study Notes, data structure, tree" />
    <link rel="alternate" type="application/rss+xml" title="RSS" href="/feed.xml">
    <meta content="1749788565247320" property="fb:app_id">
    <meta content="Study Notes" property="og:site_name">

    

    
      <meta content="Trees" property="og:title">
      <meta content="article" property="og:type">
    

    
      <meta content="My Personal Study Notes" property="og:description">
    

    
      <meta content="https://clairedeng.github.io/data%20structure/tree/2020/04/11/Trees.html" property="og:url">
    

    
      <meta content="2020-04-11T19:53:00-04:00" property="article:published_time">
      <meta content="https://clairedeng.github.io/about/" property="article:author">
    

    

    
      
        <meta content="data structure" property="article:section">
      
    

    
      
    

    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@github.io">
    <meta name="twitter:creator" content="@github.io">

    
      <meta name="twitter:title" content="Trees">
    

    
      <meta name="twitter:url" content="https://clairedeng.github.io/data%20structure/tree/2020/04/11/Trees.html">
    

    
      <meta name="twitter:description" content="My Personal Study Notes">
    

    

    <!-- Font awesome icons -->
    <link href="/static/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
    <!-- syntax highlighting CSS -->
    <link rel="stylesheet" href="/static/css/syntax.css">
    <!-- Bootstrap core CSS -->
    <link href="/static/css/bootstrap.min.css" rel="stylesheet">
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css?family=Roboto+Condensed:400,300italic,300,400italic,700&amp;subset=latin,latin-ext" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link rel="stylesheet" href="/static/css/super-search.css">
    <link rel="stylesheet" href="/static/css/thickbox.css">
    <link rel="stylesheet" href="/static/css/projects.css">
    <link rel="stylesheet" href="/static/css/main.css">

    
  </head>
  <body>
    <div class="container">
      <div class="col-sm-3">
        <div class="fixed-condition">
          <a href="/">Home</a>
          <ul class="section-nav">
<li class="toc-entry toc-h2"><a href="#basic-information">Basic Information</a></li>
<li class="toc-entry toc-h2"><a href="#tree-traversal">Tree Traversal</a>
<ul>
<li class="toc-entry toc-h3"><a href="#depth-first-traversal">Depth First Traversal</a></li>
<li class="toc-entry toc-h3"><a href="#bread-first-traversallevel-order-traversal-1-2-3-4-5">Bread First Traversal(Level Order Traversal): 1 2 3 4 5</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#binary-search-trees">Binary Search Trees</a>
<ul>
<li class="toc-entry toc-h3"><a href="#basic-implementation">Basic Implementation</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#balanced-search-trees">Balanced Search Trees</a>
<ul>
<li class="toc-entry toc-h3"><a href="#avl-trees">AVL Trees</a>
<ul>
<li class="toc-entry toc-h4"><a href="#implementation">Implementation</a></li>
</ul>
</li>
<li class="toc-entry toc-h3"><a href="#2-3-search-trees">2-3 Search Trees</a>
<ul>
<li class="toc-entry toc-h4"><a href="#red-black-tree">Red-black tree</a></li>
</ul>
</li>
</ul>
</li>
</ul>
        </div>
        <!-- end /.fixed-condition -->
      </div>
      <div class="col-sm-8 col-offset-1 main-layout">
        <header class="post-header">
  <h1 class="post-title">Trees</h1>
</header>

<div class="info">
  <span class="time">11 Apr 2020</span>
  
    <span class="categories">
      &raquo; <a href="/category/data structure">data structure</a>, <a href="/category/tree">tree</a>
    </span>
  
</div>

<div class="content">
  <div class="post"><h2 id="basic-information">Basic Information</h2>

<p><strong>Tree</strong>: Tree is recursively. A tree is a collection of nodes. The collection can be empty, otherwise, a tree consists of a distinguished node r, called the <strong>root</strong>, and zero or more nonempty (sub)trees $T_1$, $T_2$, …, $T_k$, each of whose roots are connected by a directed <strong>edge</strong> from r.</p>

<p>The root of each subtree is said to be a <strong>child</strong> of r, and r is the <strong>parent</strong> of each subtree root.</p>

<p>Nodes with no children are known as <strong>leaves</strong>.</p>

<p>Nodes with the same parent are <strong>siblings</strong>. <strong>Grandparent</strong> and <strong>grandchild</strong> relations can be defined in a similar way.</p>

<p>A <strong>path</strong> from node $n_1$ to $n_k$ is defined as a sequence of nodes $n_1, n_2, …, n_k$ such that $n_i$ is the parent of $n_{i+1}$ for $1\le i&lt;k$.</p>

<p>The <strong>length</strong> of this path is the number of this edges on the path, namely $k-1$. There is a path of length zero from every node to itself. Notice that in a tree there is exactly one path from the root to each node.</p>

<p>For any node $n_i$, the <strong>depth</strong> of $n_i$ is the length of the unique path from the root to $n_i$. Thus, the <strong>root</strong> is at <strong>depth 0</strong>.</p>

<p>The <strong>height</strong> of $n_i$ is the length of the longest path from $n_i$ to a leaf. Thus all <strong>leaves</strong> are at <strong>height 0</strong>.</p>

<p>The height of a tree is equal to the height of the root. The depth of a tree is equal to the depth of the deepest leaf; this is always equal to the height of the tree.</p>

<p><img src="https://raw.githubusercontent.com/clairedeng/clairedeng.github.io/master/static/img/_posts/1586143143884.png" alt="1586143143884" /></p>

<h2 id="tree-traversal">Tree Traversal</h2>

<p>Binary tree:</p>

<p><img src="https://raw.githubusercontent.com/clairedeng/clairedeng.github.io/master/static/img/_posts/1586086266383.png" alt="1586086266383" /></p>

<h3 id="depth-first-traversal">Depth First Traversal</h3>

<ul>
  <li>
    <p>Inorder(Left, Root, Right): 4 2 5 1 3</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Algorithm</span> <span class="nf">Inorder</span><span class="o">(</span><span class="n">tree</span><span class="o">)</span>
	<span class="mi">1</span><span class="o">.</span> <span class="nc">Traverse</span> <span class="n">the</span> <span class="n">left</span> <span class="n">subtree</span><span class="o">,</span> <span class="n">i</span><span class="o">.</span><span class="na">e</span><span class="o">.,</span> <span class="n">call</span> <span class="nf">Inorder</span><span class="o">(</span><span class="n">left</span><span class="o">-</span><span class="n">subtree</span><span class="o">)</span>
	<span class="mi">2</span><span class="o">.</span> <span class="nc">Visit</span> <span class="n">the</span> <span class="n">root</span><span class="o">.</span>
	<span class="mi">3</span><span class="o">.</span> <span class="nc">Traverse</span> <span class="n">the</span> <span class="n">right</span> <span class="n">subtree</span><span class="o">,</span> <span class="n">i</span><span class="o">.</span><span class="na">e</span><span class="o">.,</span> <span class="n">call</span> <span class="nf">Inorder</span><span class="o">(</span><span class="n">right</span><span class="o">-</span><span class="n">subtree</span><span class="o">)</span>
</code></pre></div>    </div>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">printInorder</span><span class="o">(</span><span class="nc">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span><span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
    	<span class="k">return</span><span class="o">;</span>
      
    <span class="c1">// first recur on left child</span>
    <span class="n">printInorder</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
      
    <span class="c1">// then print the data of node</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">key</span> <span class="o">+</span> <span class="s">" "</span><span class="o">);</span>
      
    <span class="c1">// second recur on right child</span>
    <span class="n">printInorder</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div>    </div>

    <p>Time Complexity: $O(n)$</p>

    <p>Space Complexity: ??????</p>

    <p>Use of Inorder:</p>

    <p>Binary search tree inorder: 1 2 3 4 5</p>

    <p><img src="https://raw.githubusercontent.com/clairedeng/clairedeng.github.io/master/static/img/_posts/1586126800164.png" alt="1586126800164" /></p>

    <p>In case of binary search trees (BST), Inorder traversal gives nodes in <strong>non-decreasing order</strong>.  To get nodes of BST in <strong>non-increasing order</strong>, search right sub tree first and then itself and right sub tree.</p>
  </li>
  <li>
    <p>Preorder(Root, Left, Right): 1 2 4 5 3</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Algorithm</span> <span class="nf">Preorder</span><span class="o">(</span><span class="n">tree</span><span class="o">)</span>
	<span class="mi">1</span><span class="o">.</span> <span class="nc">Visit</span> <span class="n">the</span> <span class="n">root</span><span class="o">.</span>
	<span class="mi">2</span><span class="o">.</span> <span class="nc">Traverse</span> <span class="n">the</span> <span class="n">left</span> <span class="n">subtree</span><span class="o">,</span> <span class="n">i</span><span class="o">.</span><span class="na">e</span><span class="o">.,</span> <span class="n">call</span> <span class="nf">Preorder</span><span class="o">(</span><span class="n">left</span><span class="o">-</span><span class="n">subtree</span><span class="o">)</span>
	<span class="mi">3</span><span class="o">.</span> <span class="n">traverse</span> <span class="n">the</span> <span class="n">right</span> <span class="n">subtree</span><span class="o">,</span> <span class="n">i</span><span class="o">.</span><span class="na">e</span><span class="o">.,</span> <span class="n">call</span> <span class="nf">Preorder</span><span class="o">(</span><span class="n">right</span><span class="o">-</span><span class="n">subtree</span><span class="o">)</span>
</code></pre></div>    </div>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">printPreorder</span><span class="o">(</span><span class="nc">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span><span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="k">return</span><span class="o">;</span>
      
    <span class="c1">// first print the data of node</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">key</span> <span class="o">+</span> <span class="s">" "</span><span class="o">);</span>
      
    <span class="c1">// then recur on left child</span>
    <span class="n">printPreorder</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
      
    <span class="c1">// second recur on right child</span>
    <span class="n">printPreorder</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div>    </div>

    <p>Time Complexity: O(n)</p>

    <p>Space Complexity: ????????</p>

    <p>Use of Preorder:</p>

    <p>Preorder traversal is used to <strong>create a copy of tree</strong>. Preorder traversal is also used to <strong>get prefix expression</strong> on of an expression tree. (why prefix expressions are useful?)</p>
  </li>
  <li>
    <p>Postorder(Left, Right, Root): 4 5 2 3 1</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Algorithm</span> <span class="nf">Postorder</span><span class="o">(</span><span class="n">tree</span><span class="o">)</span>
	<span class="mi">1</span><span class="o">.</span> <span class="nc">Traverse</span> <span class="n">the</span> <span class="n">left</span> <span class="n">subtree</span><span class="o">,</span> <span class="n">i</span><span class="o">.</span><span class="na">e</span><span class="o">.,</span> <span class="n">call</span> <span class="nf">Postorder</span><span class="o">(</span><span class="n">left</span><span class="o">-</span><span class="n">subtree</span><span class="o">)</span>
	<span class="mi">2</span><span class="o">.</span> <span class="nc">Traverse</span> <span class="n">the</span> <span class="n">right</span> <span class="n">subtree</span><span class="o">,</span> <span class="n">i</span><span class="o">.</span><span class="na">e</span><span class="o">.,</span> <span class="n">call</span> <span class="nf">Postorder</span><span class="o">(</span><span class="n">right</span><span class="o">-</span><span class="n">subtree</span><span class="o">)</span>
	<span class="mi">3</span><span class="o">.</span> <span class="nc">Visit</span> <span class="n">the</span> <span class="n">root</span>
</code></pre></div>    </div>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">printPostorder</span><span class="o">(</span><span class="nc">Node</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span><span class="o">(</span><span class="n">node</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
    	<span class="k">return</span><span class="o">;</span>
    <span class="c1">// first recur on left subtree</span>
    <span class="n">printPostorder</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
      
    <span class="c1">// then recur on right subtree</span>
    <span class="n">printPostorder</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
      
    <span class="c1">// now deal with the node</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">key</span> <span class="o">+</span> <span class="s">" "</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div>    </div>

    <p>Time Complexity: O(n)</p>

    <p>Space Complexity: ????????</p>

    <p>Use of Postorder:</p>

    <p>Postorder traversal is used to delete the tree. </p>

    <p>Postorder traversal is also useful to get the postfix expression of an expression tree. (what’s the usage of postfix expression?)</p>
  </li>
</ul>

<h3 id="bread-first-traversallevel-order-traversal-1-2-3-4-5">Bread First Traversal(Level Order Traversal): 1 2 3 4 5</h3>

<p>Implementation:</p>

<ul>
  <li>
    <p>Method 1 (Use function to print a given level) - <strong>do not recommend</strong></p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// function to print level order traversal of tree</span>
<span class="kt">void</span> <span class="nf">printLevelOrder</span><span class="o">()</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="n">height</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">h</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span>
        <span class="n">printGivenLevel</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
<span class="o">}</span>
  
<span class="c1">// Compute the height of a tree</span>
<span class="kt">int</span> <span class="nf">height</span><span class="o">(</span><span class="nc">Node</span> <span class="n">root</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="c1">//compute height of each subtree</span>
    <span class="kt">int</span> <span class="n">lheight</span> <span class="o">=</span> <span class="n">height</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
    <span class="kt">int</span> <span class="n">rheight</span> <span class="o">=</span> <span class="n">height</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
    <span class="c1">//use the larger one</span>
    <span class="k">return</span> <span class="n">lheight</span> <span class="o">&gt;</span> <span class="n">rheight</span> <span class="o">?</span> <span class="n">lheight</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">rheight</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
<span class="o">}</span>
  
<span class="c1">//print nodes at the given level</span>
<span class="kt">void</span> <span class="nf">printGivenLevel</span><span class="o">(</span><span class="nc">Node</span> <span class="n">root</span><span class="o">,</span> <span class="kt">int</span> <span class="n">level</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span><span class="o">(</span><span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="k">return</span><span class="o">;</span>
    <span class="k">if</span><span class="o">(</span><span class="n">level</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">val</span> <span class="o">+</span> <span class="s">" "</span><span class="o">);</span>
    <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">level</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">){</span>
        <span class="n">printGivenLevel</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
        <span class="n">printGivenLevel</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>    </div>

    <p>Time Complexity: $O(n^2)$. <code class="language-plaintext highlighter-rouge">printLevelOrder()</code> is $O(1) + O(2) + … + O(n - 1) + O(n)$ which is $O(n^2)$</p>

    <p>Space Complexity: $O(n)$.</p>
  </li>
  <li>
    <p>Method 2 (Using queue)</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// function to print level order traversal of tree</span>
<span class="kt">void</span> <span class="nf">printLevelOrder</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;();</span>
    <span class="n">queue</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
    <span class="k">while</span><span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
        <span class="c1">//poll() removes the present head</span>
        <span class="nc">Node</span> <span class="n">tempNode</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">tempNode</span><span class="o">.</span><span class="na">val</span> <span class="o">+</span> <span class="s">" "</span><span class="o">);</span>
        <span class="c1">//Enqueue left child</span>
        <span class="k">if</span><span class="o">(</span><span class="n">tempNode</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
            <span class="n">queue</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">tempNode</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
        <span class="c1">//Enqueue right child</span>
        <span class="k">if</span><span class="o">(</span><span class="n">tempNode</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span>
            <span class="n">queue</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">tempnode</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>    </div>

    <p>Time Complexity: $O(n)$ where n is number of nodes in the binary tree.</p>

    <p>Space Complexity: $O(n)$ where n is number of nodes in the binary tree.</p>
  </li>
</ul>

<h2 id="binary-search-trees">Binary Search Trees</h2>

<p>A <strong><em>binary search tree</em></strong> (BST) is a <em>binary tree</em> where each node has a <em>Comparable</em> key (and an associated value) and satisfies the restriction that the key in any node is larger than the keys in all nodes in that node’s left subtree and smaller than the keys in all nodes in that node’s right subtree.</p>

<p><img src="https://raw.githubusercontent.com/clairedeng/clairedeng.github.io/master/static/img/_posts/1585781535009.png" alt="1585781535009" /></p>

<h3 id="basic-implementation">Basic Implementation</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*********************************************************
 * Compilation: javac BST.java
 * Execution: java BST
 * Dependencies: StdIn.java StdOut.java Queue.java
 *
 * A symbol table implemented with a binary search tree
 *
 * % more tinyST.txt
 * S E A R C H E X A M P L E
 *
 * % java BST &lt; tinyST.txt
 * A 8
 * C 4
 * E 12
 * H 5
 * L 11
 * M 9
 * P 10
 * R 3
 * S 0
 * X 7
 *
 *************************************************************/</span>

<span class="kn">import</span> <span class="nn">java.util.NoSuchElementException</span><span class="o">;</span>
<span class="cm">/**
 * The BST class represents an ordered symbol table of generic key-value pairs.
 * It supports the usual put, get, contains, delete, size, and is-empty methods.
 * It also provides ordered methods for finding the minimum, maximum, floor, select, ceiling.
 * It also provides a keys method for iterating over all of the keys.
 * A symbol table implements the associative array abstraction: when associating a value with a key that is already in the symbol table, the convention is to replace the old value with the new value.
 * Unlike java.util.Map, this class uses the convention that values cannot be null -- setting the value associated with a key to null is equivalent to deleting the key from the symbol table.
 * It requires that the key type implements the Comparable interface and calls the compareTo() and method to compare two keys. It does not call either equals() or hashCode().
 *
 * This implementation uses an (unbalanced) binary search tree.
 * The put,contains, remove, minimum, rank operations each take Θ(n) time in the worst case, where n is the number of key-value pairs.
 * The size and is-empty operations take Θ(1) time.
 * The keys method takes Θ(n) time in the worst case.
 * Construction takes Θ(1) time.
 */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">BST</span><span class="o">&lt;</span><span class="nc">Key</span> <span class="kd">extends</span> <span class="nc">Comparable</span><span class="o">&lt;</span><span class="nc">Key</span><span class="o">&gt;,</span> <span class="nc">Value</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Node</span> <span class="n">root</span><span class="o">;</span> <span class="c1">// root of BST</span>
    <span class="kd">private</span> <span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
        <span class="kd">private</span> <span class="nc">Key</span> <span class="n">key</span><span class="o">;</span> <span class="c1">// sorted by key</span>
        <span class="kd">private</span> <span class="nc">Value</span> <span class="n">val</span><span class="o">;</span> <span class="c1">// associated data</span>
        <span class="kd">private</span> <span class="nc">Node</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">;</span> <span class="c1">// left and right subtrees</span>
        <span class="kd">private</span> <span class="kt">int</span> <span class="n">size</span><span class="o">;</span>
        <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="nc">Key</span> <span class="n">key</span><span class="o">,</span> <span class="nc">Value</span><span class="o">,</span> <span class="n">val</span><span class="o">,</span> <span class="kt">int</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">size</span> <span class="o">=</span> <span class="n">size</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="cm">/**
     * Initializes an empty symbol table.
     */</span>
    <span class="kd">public</span> <span class="nf">BST</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>
    
    <span class="cm">/**
     * Returns true if this symbol table is empty.
     */</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isEmpty</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="cm">/**
     * REturns the number of key-value pairs in this symbol table.
     */</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">size</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">size</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="c1">// return number of key-value pairs in BST rooted at x</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">size</span><span class="o">(</span><span class="nc">Node</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">else</span> <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="na">size</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="cm">/**
     * Does this symbol table contain the given key?
     */</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">contains</span><span class="o">(</span><span class="nc">Key</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">"argument to contains() is null"</span><span class="o">);</span>
        <span class="k">return</span> <span class="nf">get</span><span class="o">(</span><span class="n">key</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="cm">/**
     * Returns the value associated with the given key.
     */</span>
    <span class="kd">public</span> <span class="nc">Value</span> <span class="nf">get</span><span class="o">(</span><span class="nc">Key</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">get</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="nc">Value</span> <span class="nf">get</span><span class="o">(</span><span class="nc">Node</span> <span class="n">x</span><span class="o">,</span> <span class="nc">Key</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentEception</span><span class="o">(</span><span class="s">"calls get() with a null key"</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">cmp</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">key</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">cmp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="n">get</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
        <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">cmp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="n">get</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
        <span class="k">else</span> <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="cm">/**
     * Inserts the specified key-value pair into the symbol table, overwriting the old value with the new value if the symbol table already contains the specified key.
     * Deletes the specified key(and its associated value) from this symbol table if the specified value is null.
     */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="nc">Key</span> <span class="n">key</span><span class="o">,</span> <span class="nc">Value</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">"calls put() with a null key"</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">val</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">delete</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">put</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
        <span class="k">assert</span> <span class="nf">check</span><span class="o">();</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="nc">Node</span> <span class="nf">put</span><span class="o">(</span><span class="nc">Node</span> <span class="n">x</span><span class="o">,</span> <span class="nc">Key</span> <span class="n">key</span><span class="o">,</span> <span class="nc">Value</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">cmp</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">key</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">cmp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="n">x</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">put</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
        <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">cmp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="n">x</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span><span class="n">put</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
        <span class="k">else</span> <span class="n">x</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">;</span>
        <span class="n">x</span><span class="o">.</span><span class="na">size</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">size</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">+</span> <span class="n">size</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="cm">/**
     * Removes the smallest key and associated value from the symbol table.
     */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">deleteMin</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">isEmpty</span><span class="o">())</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">NoSuchElementException</span><span class="o">(</span><span class="s">"Symbol table underflow"</span><span class="o">);</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">deleteMin</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        <span class="k">assert</span> <span class="nf">check</span><span class="o">();</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="nc">Node</span> <span class="nf">deleteMin</span><span class="o">(</span><span class="nc">Node</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
        <span class="n">x</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">deleteMin</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
        <span class="n">x</span><span class="o">.</span><span class="na">size</span> <span class="o">=</span> <span class="n">size</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">+</span> <span class="n">size</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="cm">/**
     * Removes the largest key and associated value from the symbol table.
     */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">deleteMax</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">isEmpty</span><span class="o">())</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">NoSuchElementException</span><span class="o">(</span><span class="s">"Symbol table overflow"</span><span class="o">);</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">deleteMax</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        <span class="k">assert</span> <span class="nf">check</span><span class="o">();</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="nc">Node</span> <span class="nf">deleteMax</span><span class="o">(</span><span class="nc">Node</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
        <span class="n">x</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">deleteMax</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        <span class="n">x</span><span class="o">.</span><span class="na">size</span> <span class="o">=</span> <span class="n">size</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">+</span> <span class="n">size</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="cm">/**
     * Removes the specified key and its associated value from this symbol table(if the key is in this symbol table)
     */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">delete</span><span class="o">(</span><span class="nc">Key</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">"calls delete() with a null key"</span><span class="o">);</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">delete</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
        <span class="k">assert</span> <span class="nf">check</span><span class="o">();</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="nc">Node</span> <span class="nf">delete</span><span class="o">(</span><span class="nc">Node</span> <span class="n">x</span><span class="o">,</span> <span class="nc">Key</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">cmp</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">compateTo</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">key</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">cmp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="n">x</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">delete</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
        <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">cmp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="n">x</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">delete</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
            <span class="nc">Node</span> <span class="n">t</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">min</span><span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
            <span class="n">x</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">deleteMin</span><span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
            <span class="n">x</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">x</span><span class="o">.</span><span class="na">size</span> <span class="o">=</span> <span class="n">size</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">+</span> <span class="n">size</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="cm">/**
     * Returns the smallest key in the symbol table.
     */</span>
    <span class="kd">public</span> <span class="nc">Key</span> <span class="nf">min</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">isEmpty</span><span class="o">())</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">NoSuchElemntException</span><span class="o">(</span><span class="s">"calls min() with symbol table"</span><span class="o">);</span>
        <span class="k">return</span> <span class="nf">min</span><span class="o">(</span><span class="n">root</span><span class="o">).</span><span class="na">key</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="nc">Node</span> <span class="nf">min</span><span class="o">(</span><span class="nc">Node</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
        <span class="k">else</span> <span class="k">return</span> <span class="nf">min</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="cm">/**
     * Returns the largest key in the symbol table
     */</span>
    <span class="kd">public</span> <span class="nc">Key</span> <span class="nf">max</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">isEmpty</span><span class="o">())</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">NoSuchElementException</span><span class="o">(</span><span class="s">"calls max() with empty symbol table"</span><span class="o">);</span>
        <span class="k">return</span> <span class="nf">max</span><span class="o">(</span><span class="n">root</span><span class="o">).</span><span class="na">key</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="nc">Node</span> <span class="nf">max</span><span class="o">(</span><span class="nc">Node</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
        <span class="k">else</span> <span class="k">return</span> <span class="nf">max</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="cm">/**
     * Returns the largest key in the symbol table less than or equal to key.
     */</span>
    <span class="kd">public</span> <span class="nc">Key</span> <span class="nf">floor</span><span class="o">(</span><span class="nc">Key</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentEception</span><span class="o">(</span><span class="s">"argument to floor() is null"</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">isEmpty</span><span class="o">())</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">NoSuchElementException</span><span class="o">(</span><span class="s">"calls floor with empty symbol table"</span><span class="o">);</span>
        <span class="nc">Node</span> <span class="n">x</span> <span class="o">=</span> <span class="n">floor</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">NoSuchElementException</span><span class="o">(</span><span class="s">"argument to floor() is too small"</span><span class="o">);</span>
        <span class="k">else</span> <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="na">key</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="nc">Node</span> <span class="nf">floor</span><span class="o">(</span><span class="nc">Node</span> <span class="n">x</span><span class="o">,</span> <span class="nc">Key</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">cmp</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">key</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">cmp</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">cmp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="n">floor</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
        <span class="nc">Node</span> <span class="n">t</span> <span class="o">=</span> <span class="n">floor</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">t</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">t</span><span class="o">;</span>
        <span class="k">else</span> <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="nc">Key</span> <span class="nf">floor2</span><span class="o">(</span><span class="nc">Key</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Key</span> <span class="n">x</span> <span class="o">=</span> <span class="n">floor2</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">NoSuchElementException</span><span class="o">(</span><span class="s">"argument to floor() is too small"</span><span class="o">);</span>
        <span class="k">else</span> <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="nc">Key</span> <span class="nf">floor2</span><span class="o">(</span><span class="nc">Node</span> <span class="n">x</span><span class="o">,</span> <span class="nc">Key</span> <span class="n">key</span><span class="o">,</span> <span class="nc">Key</span> <span class="n">best</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">best</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">cmp</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">key</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">cmp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="n">floor2</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">best</span><span class="o">);</span>
        <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">cmp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="n">floor2</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">x</span><span class="o">.</span><span class="na">key</span><span class="o">);</span>
        <span class="k">else</span> <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="na">key</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="cm">/**
     * Returns the smallest key in the symbol table greater than or equal to key.
     */</span>
    <span class="kd">public</span> <span class="nc">Key</span> <span class="nf">ceiling</span><span class="o">(</span><span class="nc">Key</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">"argument to ceiling() is null"</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">isEmmpty</span><span class="o">())</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">NoSuchElementException</span><span class="o">(</span><span class="s">"calls ceiling() with empty symbol table"</span><span class="o">);</span>
        <span class="nc">Node</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ceiling</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">NoSuchElementException</span><span class="o">(</span><span class="s">"argument to floor() is too large"</span><span class="o">);</span>
        <span class="k">else</span> <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="na">key</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="nc">Node</span> <span class="nf">ceiling</span><span class="o">(</span><span class="nc">Node</span> <span class="n">x</span><span class="o">,</span> <span class="nc">Key</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">cmp</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">key</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">cmp</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">cmp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="n">ceiling</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
        <span class="nc">Node</span> <span class="n">t</span> <span class="o">=</span> <span class="n">ceiling</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">t</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">t</span><span class="o">;</span>
        <span class="k">else</span> <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="cm">/**
     * Return the key in the symbol table of a given rank. This key has the property that there are rank keys in they symbol table that are smaller. In other words, this key is the rank+1 st smallest key in the symbol table.
     */</span>
    <span class="kd">public</span> <span class="nc">Key</span> <span class="nf">select</span><span class="o">(</span><span class="kt">int</span> <span class="n">rank</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">rank</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">rank</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"argument to select() is invalid: "</span> <span class="o">+</span> <span class="n">rank</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="nf">select</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">rank</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="c1">//Return key in BST rooted at x of given rank</span>
    <span class="kd">private</span> <span class="nc">Key</span> <span class="nf">select</span><span class="o">(</span><span class="nc">Node</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">rank</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">leftSize</span> <span class="o">=</span> <span class="n">size</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">leftSize</span> <span class="o">&gt;</span> <span class="n">rank</span><span class="o">)</span> <span class="k">return</span> <span class="n">select</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">rank</span><span class="o">);</span>
        <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">leftSize</span> <span class="o">&lt;</span> <span class="n">rank</span><span class="o">)</span> <span class="k">return</span> <span class="n">select</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">rank</span><span class="o">-</span><span class="n">leftSize</span>  <span class="o">-</span><span class="mi">1</span><span class="o">);</span>
        <span class="k">else</span> <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="na">key</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="cm">/**
     * Return the number of keys in the symbol table strictly less than key.
     */</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">rank</span><span class="o">(</span><span class="nc">Key</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentExxception</span><span class="o">(</span><span class="s">"argument to rank() is null"</span><span class="o">);</span>
        <span class="k">return</span> <span class="nf">rank</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">root</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="c1">// Number of keys in the subtree less than key.</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">rank</span><span class="o">(</span><span class="nc">Key</span> <span class="n">key</span><span class="o">,</span> <span class="nc">Node</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">cmp</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">key</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">cmp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="n">rank</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">cmp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">size</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">+</span> <span class="n">rank</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        <span class="k">else</span> <span class="k">return</span> <span class="nf">size</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="cm">/**
     * Returns all keys in the symbol table as an Iterable.
     * To iterate over all of the keys in the symbol table named st,
     * use the foreach notation: for(Key key: st.keys()).
     */</span>
    <span class="kd">public</span> <span class="nc">Iterable</span><span class="o">&lt;</span><span class="nc">Key</span><span class="o">&gt;</span> <span class="nf">keys</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">isEmpty</span><span class="o">())</span> <span class="k">return</span> <span class="k">new</span> <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Key</span><span class="o">&gt;();</span>
        <span class="k">return</span> <span class="nf">keys</span><span class="o">(</span><span class="n">min</span><span class="o">(),</span> <span class="n">max</span><span class="o">());</span>
    <span class="o">}</span>
    
    <span class="cm">/**
     * Returns all keys in the symbol table in the given renge, as an iterable
     */</span>
    <span class="kd">public</span> <span class="nc">Iterable</span><span class="o">&lt;</span><span class="nc">Key</span><span class="o">&gt;</span> <span class="nf">keys</span><span class="o">(</span><span class="nc">Key</span> <span class="n">lo</span><span class="o">,</span> <span class="nc">Key</span> <span class="n">hi</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">lo</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">"first argument to keys() is null"</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">hi</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">"second argument to keys() is null"</span><span class="o">);</span> 
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Key</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Key</span><span class="o">&gt;();</span>
        <span class="n">keys</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">queue</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">hi</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">queue</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">keys</span><span class="o">(</span><span class="nc">Node</span> <span class="n">x</span><span class="o">,</span> <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Key</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">,</span> <span class="nc">Key</span> <span class="n">lo</span><span class="o">,</span> <span class="nc">Key</span> <span class="n">hi</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">cmplo</span> <span class="o">=</span> <span class="n">lo</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">key</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">cmphi</span> <span class="o">=</span> <span class="n">hi</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">key</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">cmplo</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="n">keys</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">queue</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">hi</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">cmplo</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">cmphi</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="n">queue</span><span class="o">.</span><span class="na">enqueue</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">key</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">cmphi</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="n">keys</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">queue</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">hi</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="cm">/**
     * Returns the number of keys in the symbol table in the given range.
     */</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">size</span><span class="o">(</span><span class="nc">Key</span> <span class="n">lo</span><span class="o">,</span> <span class="nc">Key</span> <span class="n">hi</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">lo</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">"First argument to size() is null"</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">hi</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">"Second argument to size() is null"</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">lo</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">hi</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">contains</span><span class="o">(</span><span class="n">hi</span><span class="o">))</span> <span class="k">return</span> <span class="n">rank</span><span class="o">(</span><span class="n">hi</span><span class="o">)</span> <span class="o">-</span> <span class="n">rank</span><span class="o">(</span><span class="n">lo</span><span class="o">)</span> <span class="o">+</span><span class="mi">1</span><span class="o">;</span>
        <span class="k">else</span> <span class="k">return</span> <span class="nf">rank</span><span class="o">(</span><span class="n">hi</span><span class="o">)</span> <span class="o">-</span> <span class="n">rank</span><span class="o">(</span><span class="n">lo</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="cm">/**
     * Returns the height of the BST (for debugging).
     */</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">height</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">height</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">height</span><span class="o">(</span><span class="nc">Node</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">height</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">),</span> <span class="n">height</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">));</span>
    <span class="o">}</span>
    
    <span class="cm">/**
     * Returns the keys in the BST in level order (for debugging).
     */</span>
    <span class="kd">public</span> <span class="nc">Iterable</span><span class="o">&lt;</span><span class="nc">Key</span><span class="o">&gt;</span> <span class="nf">levelOrder</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Key</span><span class="o">&gt;</span> <span class="n">keys</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Key</span><span class="o">&gt;();</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;();</span>
        <span class="n">queue</span><span class="o">.</span><span class="na">enqueue</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        <span class="k">while</span><span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="nc">Node</span> <span class="n">x</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">dequeue</span><span class="o">();</span>
            <span class="k">if</span><span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">continue</span><span class="o">;</span>
            <span class="n">keys</span><span class="o">.</span><span class="na">enqueue</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">key</span><span class="o">);</span>
            <span class="n">queue</span><span class="o">.</span><span class="na">enqueue</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
            <span class="n">queue</span><span class="o">.</span><span class="na">enqueue</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">keys</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="cm">/**************************************************************
     * Check intergrity of BST data structure.
     *************************************************************/</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">check</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(!</span><span class="n">isBST</span><span class="o">())</span> <span class="nc">StdOut</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Not in symmetric order"</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(!</span><span class="n">isSizeConsistent</span><span class="o">())</span> <span class="nc">StdOut</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Subtree counts not consistent"</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(!</span><span class="n">isRankConsistent</span><span class="o">())</span> <span class="nc">StdOut</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Ranks not consistent"</span><span class="o">);</span>
        <span class="k">return</span> <span class="nf">isBST</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">isSizeConsistent</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">isRankConsistent</span><span class="o">();</span>
    <span class="o">}</span>
    
    <span class="c1">// does this binary tree satisfy symmetric order?</span>
    <span class="c1">// Note: this test also ensures that data structure is a binary tree since order is strict</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">isBST</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">isBST</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="c1">// is the tree rooted at x a BST with all keys strictly between min and max</span>
    <span class="c1">// if min or max is null, treat as empty constraint</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">isBST</span><span class="o">(</span><span class="nc">Node</span> <span class="n">x</span><span class="o">,</span> <span class="nc">Key</span> <span class="n">min</span><span class="o">,</span> <span class="nc">Key</span> <span class="n">max</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">min</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">x</span><span class="o">.</span><span class="na">key</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">min</span><span class="o">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">max</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">x</span><span class="o">.</span><span class="na">key</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">max</span><span class="o">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">return</span> <span class="nf">isBST</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">min</span><span class="o">,</span> <span class="n">x</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">isBST</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">x</span><span class="o">.</span><span class="na">key</span><span class="o">,</span> <span class="n">max</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="c1">//are the size fields correct?</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">isSizeConsistent</span><span class="o">()</span> <span class="o">{</span><span class="k">return</span> <span class="n">isSizeConsistent</span><span class="o">(</span><span class="n">root</span><span class="o">);}</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">isSizeConsistent</span><span class="o">(</span><span class="nc">Node</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">size</span> <span class="o">!=</span> <span class="n">size</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">+</span> <span class="n">size</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">)</span>  <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">return</span> <span class="nf">isSizeConsistent</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">isSizeConsistent</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="c1">//check that ranks are consistent</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">isRankConsistent</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span>
            <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">rank</span><span class="o">(</span><span class="n">select</span><span class="o">(</span><span class="n">i</span><span class="o">)))</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="nc">Key</span> <span class="n">key</span> <span class="o">:</span> <span class="n">keys</span><span class="o">())</span>
            <span class="k">if</span><span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">select</span><span class="o">(</span><span class="n">rank</span><span class="o">(</span><span class="n">key</span><span class="o">)))</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="cm">/**
     * Unit tests the BST data type
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="no">BST</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="no">BST</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="o">!</span><span class="nc">StdIn</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">key</span> <span class="o">=</span> <span class="nc">StdIn</span><span class="o">.</span><span class="na">readString</span><span class="o">();</span>
            <span class="n">st</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">for</span><span class="o">(</span><span class="nc">String</span> <span class="nl">s:</span> <span class="n">st</span><span class="o">.</span><span class="na">levelOrder</span><span class="o">())</span>
            <span class="nc">StdOut</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span> <span class="o">+</span> <span class="s">" "</span> <span class="o">+</span> <span class="n">st</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">s</span><span class="o">));</span>
        <span class="nc">StdOut</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
        <span class="k">for</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span> <span class="o">:</span> <span class="n">st</span><span class="o">.</span><span class="na">keys</span><span class="o">())</span>
            <span class="nc">StdOut</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span> <span class="o">+</span> <span class="s">" "</span> <span class="o">+</span> <span class="n">st</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">s</span><span class="o">));</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="balanced-search-trees">Balanced Search Trees</h2>

<h3 id="avl-trees">AVL Trees</h3>

<h4 id="implementation">Implementation</h4>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rotateleft();
rotateright();
</code></pre></div></div>

<h3 id="2-3-search-trees">2-3 Search Trees</h3>

<p>A 2-3 search tree is a tree that either is empty or:</p>

<ul>
  <li>A 2-node, with one key (and associated value) and two links, a left link to a 2-3 search tree with smaller keys, and a right link to a 2-3 search tree with larger keys</li>
  <li>A 3-node, with two keys (and associated values) and three links, a left link to a 2-3 search tree with smaller keys, a middle link to a 2-3 search tree with keys between the node’s keys and a right link to a 2-3 search tree with larger keys.</li>
</ul>

<h4 id="red-black-tree">Red-black tree</h4>

<p>#####Implementation</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/********************************************************************
 * Compilation: javac RedBlackBST.java
 * Execution: java RedBlackBST &lt; input.txt
 *
 * A symbol table implemented using a left-leaning red-black BST.
 * This is the 2-3 version.
 *
 *********************************************************************/</span>
<span class="kn">import</span> <span class="nn">java.util.NoSuchElementException</span><span class="o">;</span>

<span class="cm">/**
 * The BST class represents an ordered symbol table of generic key-value pairs.
 * It supports the usual put, get, contains, delete, size and is-empty methods.
 * It also provides ordered methods for finding th minimum, maximum, floor and ceiling.
 * It also provides a keys method for iterating over all of the keys.
 * A symbol table implements the associative array abstraction : when associating a value with a key that is already in the symbol table, the convention is to replace the old value with the new value.
 * Unlike java.util.Map, this class uses the convention that values cannot be null - setting the value associated with a key to null is equivalent to deleting the key from the symbol table. 
 * It requires that the key type implements the Comparable interface and calls the compareTo() and method to compare two keys. It does not call either equals() or hashCode().
 * This implementation uses a left-leaning red-black BST.
 * The put, get, contains, remove, minimum, maximum, ceiling, floor, rank, and select operations each take Θ(log n) time in the worst case, where n is the number of key-value pairs in the symbok table.
 * The size, and is-empty operations take Θ(1) time.
 * The keys method take O(log n + m), where m is the number of keys returned by the iterator.
 * Construction takes Θ(1) time.
 *
 * For alternative implementations of the symbol table API, see ST, BinarySerachST, SequentialSearchST, BST, SeparateChainingHashST, LinearProbingHashST, and AVLTreeST.
 */</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RedBlackBST</span><span class="o">&lt;</span><span class="nc">Key</span> <span class="kd">extends</span> <span class="nc">Comparable</span><span class="o">&lt;</span><span class="nc">Key</span><span class="o">&gt;,</span> <span class="n">value</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="no">RED</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="no">BLACK</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
    
    <span class="kd">private</span> <span class="nc">Node</span> <span class="n">root</span><span class="o">;</span> <span class="c1">// root of the BST</span>
    
    <span class="c1">//BST helper node data type</span>
    <span class="kd">private</span> <span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
        <span class="kd">private</span> <span class="nc">Key</span> <span class="n">key</span><span class="o">;</span> <span class="c1">// key</span>
        <span class="kd">private</span> <span class="nc">Value</span> <span class="n">val</span><span class="o">;</span> <span class="c1">// associate data</span>
        <span class="kd">private</span> <span class="nc">Node</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">;</span> <span class="c1">// links to left and right subtrees</span>
        <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">color</span><span class="o">;</span> <span class="c1">// color of parent link</span>
        <span class="kd">private</span> <span class="kt">int</span> <span class="n">size</span><span class="o">;</span> <span class="c1">// subtree count</span>
        
        <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="nc">Key</span> <span class="n">key</span><span class="o">,</span> <span class="nc">Value</span> <span class="n">val</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">color</span><span class="o">,</span> <span class="kt">int</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="n">color</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">size</span> <span class="o">=</span> <span class="n">size</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="cm">/**
     * Initializes an empty symbol table.
     */</span>
    <span class="kd">public</span> <span class="nf">RedBlackBST</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">}</span>
    
    <span class="cm">/***************************************************************************
     * Node helper methods.
     ***************************************************************************/</span>
    <span class="c1">// is node x red; false if x is null</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">isRed</span><span class="o">(</span><span class="nc">Node</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="na">color</span> <span class="o">==</span> <span class="no">RED</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="c1">//number of node in subtree rooted at x; 0 if x is null</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">size</span><span class="o">(</span><span class="nc">Node</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="na">size</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="cm">/**
     * Returns the number of key-value pairs in this symbol table.
     */</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">size</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">size</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="cm">/**
     * Is this symbol table empty
     */</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isEmpty</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">root</span> <span class="o">==</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="cm">/*************************************************************************
     * Standard BST search.
     *************************************************************************/</span>
    
    <span class="cm">/**
     * Returns the value associated with the given key.
     */</span>
    <span class="kd">public</span> <span class="nc">Value</span> <span class="nf">get</span><span class="o">(</span><span class="nc">Key</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgmentException</span><span class="o">(</span><span class="s">"argument to get() is null"</span><span class="o">);</span>
        <span class="k">return</span> <span class="nf">get</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="c1">//value associated with the given key in subtree rooted at x; null if no such key</span>
    <span class="kd">private</span> <span class="nc">Value</span> <span class="nf">get</span><span class="o">(</span><span class="nc">Node</span> <span class="n">x</span><span class="o">,</span> <span class="nc">Key</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">while</span><span class="o">(</span><span class="n">x</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">cmp</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">key</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">cmp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
            <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">cmp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
            <span class="k">else</span> <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="cm">/**
     * Does this symbol table contains the given key?
     */</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">contains</span><span class="o">(</span><span class="nc">Key</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">get</span><span class="o">(</span><span class="n">key</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="cm">/**************************************************************************
     * Red-black tree insertion.
     **************************************************************************/</span>
    
    <span class="cm">/**
     * Inserts the specified key-value pair into the symbol table, overwriting the old value with the new value if the symbol table already contains the specified key.
     * Deletes the specified key (and its associated value) form this symbol table if the specified value is null.
     */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="nc">Key</span> <span class="n">key</span><span class="o">,</span> <span class="nc">Value</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">"First argument to put() is null"</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">val</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">delete</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">put</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
        <span class="n">root</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="no">BLACK</span><span class="o">;</span>
        <span class="c1">//assert check();</span>
    <span class="o">}</span>
    
    <span class="c1">// insert the key-value pair in the subtree rooted at h</span>
    <span class="kd">private</span> <span class="nc">Node</span> <span class="nf">put</span><span class="o">(</span><span class="nc">Node</span> <span class="n">h</span><span class="o">,</span> <span class="nc">Key</span> <span class="n">key</span><span class="o">,</span> <span class="nc">Value</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">h</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">,</span> <span class="no">RED</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">cmp</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">key</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">cmp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span><span class="n">h</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">put</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
        <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">cmp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="n">h</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">put</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
        <span class="k">else</span> <span class="n">h</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">;</span>
        
        <span class="c1">//fix-up any right-leaning links</span>
        <span class="k">if</span><span class="o">(</span><span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">))</span> <span class="n">h</span> <span class="o">=</span> <span class="n">rotateLeft</span><span class="o">(</span><span class="n">h</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">left</span><span class="o">))</span> <span class="n">h</span> <span class="o">=</span> <span class="n">rotateRight</span><span class="o">(</span><span class="n">h</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">))</span> <span class="n">flipColors</span><span class="o">(</span><span class="n">h</span><span class="o">);</span>
        <span class="n">h</span><span class="o">.</span><span class="na">size</span> <span class="o">=</span> <span class="n">size</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">+</span> <span class="n">size</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">h</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="cm">/************************************************************************
     * Remove the smallest key and associated value from the symbol table.
     ************************************************************************/</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">deleteMin</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">isEmpty</span><span class="o">())</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">NoSuchElementException</span><span class="o">(</span><span class="s">"BST underflow"</span><span class="o">);</span>
        
        <span class="c1">//if both children of root are black, set root to red</span>
        <span class="k">if</span><span class="o">(!</span><span class="n">isRed</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isRed</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">))</span>
            <span class="n">root</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="no">RED</span><span class="o">;</span>
        
        <span class="n">root</span> <span class="o">=</span> <span class="n">deleteMin</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(!</span><span class="n">isEmpty</span><span class="o">())</span> <span class="n">root</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="no">BLACK</span><span class="o">;</span>
        <span class="c1">//assert check();</span>
    <span class="o">}</span>
    
    <span class="c1">// delete the key-value pair with the minimum key rooted at h</span>
    <span class="kd">private</span> <span class="nc">Node</span> <span class="nf">deleteMin</span><span class="o">(</span><span class="nc">Node</span> <span class="n">h</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        
        <span class="k">if</span><span class="o">(!</span><span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">left</span><span class="o">))</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">moveRedLeft</span><span class="o">(</span><span class="n">h</span><span class="o">);</span>
        
        <span class="n">h</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">deleteMin</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
        <span class="k">return</span> <span class="nf">balance</span><span class="o">(</span><span class="n">h</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="cm">/**
     * Remove the largest key and associated value from the symbol table.
     */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">deleteMax</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">isEmpty</span><span class="o">())</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">NoSuchElementException</span><span class="o">(</span><span class="s">"BST underflow"</span><span class="o">);</span>
        
        <span class="c1">//if both children of root are black, set root to red</span>
        <span class="k">if</span><span class="o">(!</span><span class="n">isRed</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isRed</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">))</span>
            <span class="n">root</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="no">RED</span><span class="o">;</span>
        
        <span class="n">root</span> <span class="o">=</span> <span class="n">deleteMax</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(!</span><span class="n">isEmpty</span><span class="o">())</span> <span class="n">root</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="no">BLACK</span><span class="o">;</span>
        <span class="c1">//assert check();</span>
    <span class="o">}</span>
    
    <span class="c1">// delete the key-value pair with the maximum key rooted at h</span>
    <span class="kd">private</span> <span class="nc">Node</span> <span class="nf">deleteMax</span><span class="o">(</span><span class="nc">Node</span> <span class="n">h</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">))</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">rotateRight</span><span class="o">(</span><span class="n">h</span><span class="o">);</span>
        
        <span class="k">if</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        
        <span class="k">if</span><span class="o">(!</span><span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">left</span><span class="o">))</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">moveRedRight</span><span class="o">(</span><span class="n">h</span><span class="o">);</span>
        
        <span class="n">h</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">deleteMax</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
        <span class="k">return</span> <span class="nf">balance</span><span class="o">(</span><span class="n">h</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="cm">/**
     * Removes the specified key and its associated value from this symbol table
     */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">delete</span><span class="o">(</span><span class="nc">Key</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">"argument to delete() is null"</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(!</span><span class="n">contains</span><span class="o">(</span><span class="n">key</span><span class="o">))</span> <span class="k">return</span><span class="o">;</span>
        
        <span class="c1">// if both children of root are black, set root to red</span>
        <span class="k">if</span><span class="o">(!</span><span class="n">isRed</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isRed</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">right</span><span class="o">))</span>
            <span class="n">root</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="no">RED</span><span class="o">;</span>
        
        <span class="n">root</span> <span class="o">=</span> <span class="n">delete</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(!</span><span class="n">isEmpty</span><span class="o">())</span> <span class="n">root</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="no">BLACK</span><span class="o">;</span>
        <span class="c1">//assert check();</span>
    <span class="o">}</span>
    
    <span class="c1">// delete the key-value pair with the given key rooted at h</span>
    <span class="kd">private</span> <span class="nc">Node</span> <span class="nf">delete</span><span class="o">(</span><span class="nc">Node</span> <span class="n">h</span><span class="o">,</span> <span class="nc">Key</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//assert get(h, key) != null;</span>
        
        <span class="k">if</span><span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">left</span><span class="o">))</span>
                <span class="n">h</span> <span class="o">=</span> <span class="n">moveRedLeft</span><span class="o">(</span><span class="n">h</span><span class="o">);</span>
            <span class="n">h</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">delete</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">))</span>
                <span class="n">h</span> <span class="o">=</span> <span class="n">rotateRight</span><span class="o">(</span><span class="n">h</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">))</span>
                <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">left</span><span class="o">))</span>
                <span class="n">h</span> <span class="o">=</span> <span class="n">moveRedRight</span><span class="o">(</span><span class="n">h</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">Node</span> <span class="n">x</span> <span class="o">=</span> <span class="n">min</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
                <span class="n">h</span><span class="o">.</span><span class="na">key</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">key</span><span class="o">;</span>
                <span class="n">h</span><span class="o">.</span><span class="na">val</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">val</span><span class="o">;</span>
                <span class="n">h</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">deleteMin</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="n">h</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">delete</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="nf">balance</span><span class="o">(</span><span class="n">h</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="cm">/***************************************************************************
    *  Red-black tree helper functions.
    ***************************************************************************/</span>

    <span class="c1">// make a left-leaning link lean to the right</span>
    <span class="kd">private</span> <span class="nc">Node</span> <span class="nf">rotateRight</span><span class="o">(</span><span class="nc">Node</span> <span class="n">h</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// assert (h != null) &amp;&amp; isRed(h.left);</span>
        <span class="nc">Node</span> <span class="n">x</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
        <span class="n">h</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
        <span class="n">x</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">h</span><span class="o">;</span>
        <span class="n">x</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">color</span><span class="o">;</span>
        <span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="no">RED</span><span class="o">;</span>
        <span class="n">x</span><span class="o">.</span><span class="na">size</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="na">size</span><span class="o">;</span>
        <span class="n">h</span><span class="o">.</span><span class="na">size</span> <span class="o">=</span> <span class="n">size</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">+</span> <span class="n">size</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// make a right-leaning link lean to the left</span>
    <span class="kd">private</span> <span class="nc">Node</span> <span class="nf">rotateLeft</span><span class="o">(</span><span class="nc">Node</span> <span class="n">h</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// assert (h != null) &amp;&amp; isRed(h.right);</span>
        <span class="nc">Node</span> <span class="n">x</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
        <span class="n">h</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
        <span class="n">x</span><span class="o">.</span><span class="na">left</span> <span class="o">=</span> <span class="n">h</span><span class="o">;</span>
        <span class="n">x</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">color</span><span class="o">;</span>
        <span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="no">RED</span><span class="o">;</span>
        <span class="n">x</span><span class="o">.</span><span class="na">size</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="na">size</span><span class="o">;</span>
        <span class="n">h</span><span class="o">.</span><span class="na">size</span> <span class="o">=</span> <span class="n">size</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">+</span> <span class="n">size</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// flip the colors of a node and its two children</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">flipColors</span><span class="o">(</span><span class="nc">Node</span> <span class="n">h</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// h must have opposite color of its two children</span>
        <span class="c1">// assert (h != null) &amp;&amp; (h.left != null) &amp;&amp; (h.right != null);</span>
        <span class="c1">// assert (!isRed(h) &amp;&amp;  isRed(h.left) &amp;&amp;  isRed(h.right))</span>
        <span class="c1">//    || (isRed(h)  &amp;&amp; !isRed(h.left) &amp;&amp; !isRed(h.right));</span>
        <span class="n">h</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="o">!</span><span class="n">h</span><span class="o">.</span><span class="na">color</span><span class="o">;</span>
        <span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="o">!</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">color</span><span class="o">;</span>
        <span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="o">!</span><span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">color</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// Assuming that h is red and both h.left and h.left.left</span>
    <span class="c1">// are black, make h.left or one of its children red.</span>
    <span class="kd">private</span> <span class="nc">Node</span> <span class="nf">moveRedLeft</span><span class="o">(</span><span class="nc">Node</span> <span class="n">h</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// assert (h != null);</span>
        <span class="c1">// assert isRed(h) &amp;&amp; !isRed(h.left) &amp;&amp; !isRed(h.left.left);</span>

        <span class="n">flipColors</span><span class="o">(</span><span class="n">h</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">.</span><span class="na">left</span><span class="o">))</span> <span class="o">{</span> 
            <span class="n">h</span><span class="o">.</span><span class="na">right</span> <span class="o">=</span> <span class="n">rotateRight</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">rotateLeft</span><span class="o">(</span><span class="n">h</span><span class="o">);</span>
            <span class="n">flipColors</span><span class="o">(</span><span class="n">h</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">h</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// Assuming that h is red and both h.right and h.right.left</span>
    <span class="c1">// are black, make h.right or one of its children red.</span>
    <span class="kd">private</span> <span class="nc">Node</span> <span class="nf">moveRedRight</span><span class="o">(</span><span class="nc">Node</span> <span class="n">h</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// assert (h != null);</span>
        <span class="c1">// assert isRed(h) &amp;&amp; !isRed(h.right) &amp;&amp; !isRed(h.right.left);</span>
        <span class="n">flipColors</span><span class="o">(</span><span class="n">h</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">left</span><span class="o">))</span> <span class="o">{</span> 
            <span class="n">h</span> <span class="o">=</span> <span class="n">rotateRight</span><span class="o">(</span><span class="n">h</span><span class="o">);</span>
            <span class="n">flipColors</span><span class="o">(</span><span class="n">h</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">h</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// restore red-black tree invariant</span>
    <span class="kd">private</span> <span class="nc">Node</span> <span class="nf">balance</span><span class="o">(</span><span class="nc">Node</span> <span class="n">h</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// assert (h != null);</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">))</span>                      <span class="n">h</span> <span class="o">=</span> <span class="n">rotateLeft</span><span class="o">(</span><span class="n">h</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">.</span><span class="na">left</span><span class="o">))</span> <span class="n">h</span> <span class="o">=</span> <span class="n">rotateRight</span><span class="o">(</span><span class="n">h</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">isRed</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">))</span>     <span class="n">flipColors</span><span class="o">(</span><span class="n">h</span><span class="o">);</span>

        <span class="n">h</span><span class="o">.</span><span class="na">size</span> <span class="o">=</span> <span class="n">size</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">+</span> <span class="n">size</span><span class="o">(</span><span class="n">h</span><span class="o">.</span><span class="na">right</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">h</span><span class="o">;</span>
    <span class="o">}</span>


   <span class="cm">/***************************************************************************
    *  Utility functions.
    ***************************************************************************/</span>

    <span class="cm">/**
     * Returns the height of the BST (for debugging).
     * @return the height of the BST (a 1-node tree has height 0)
     */</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">height</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">height</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">height</span><span class="o">(</span><span class="nc">Node</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">height</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">),</span> <span class="n">height</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">));</span>
    <span class="o">}</span>

   <span class="cm">/***************************************************************************
    *  Ordered symbol table methods.
    ***************************************************************************/</span>

    <span class="cm">/**
     * Returns the smallest key in the symbol table.
     * @return the smallest key in the symbol table
     * @throws NoSuchElementException if the symbol table is empty
     */</span>
    <span class="kd">public</span> <span class="nc">Key</span> <span class="nf">min</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">isEmpty</span><span class="o">())</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">NoSuchElementException</span><span class="o">(</span><span class="s">"calls min() with empty symbol table"</span><span class="o">);</span>
        <span class="k">return</span> <span class="nf">min</span><span class="o">(</span><span class="n">root</span><span class="o">).</span><span class="na">key</span><span class="o">;</span>
    <span class="o">}</span> 

    <span class="c1">// the smallest key in subtree rooted at x; null if no such key</span>
    <span class="kd">private</span> <span class="nc">Node</span> <span class="nf">min</span><span class="o">(</span><span class="nc">Node</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span> 
        <span class="c1">// assert x != null;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">x</span><span class="o">;</span> 
        <span class="k">else</span>                <span class="k">return</span> <span class="nf">min</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">);</span> 
    <span class="o">}</span> 

    <span class="cm">/**
     * Returns the largest key in the symbol table.
     * @return the largest key in the symbol table
     * @throws NoSuchElementException if the symbol table is empty
     */</span>
    <span class="kd">public</span> <span class="nc">Key</span> <span class="nf">max</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">isEmpty</span><span class="o">())</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">NoSuchElementException</span><span class="o">(</span><span class="s">"calls max() with empty symbol table"</span><span class="o">);</span>
        <span class="k">return</span> <span class="nf">max</span><span class="o">(</span><span class="n">root</span><span class="o">).</span><span class="na">key</span><span class="o">;</span>
    <span class="o">}</span> 

    <span class="c1">// the largest key in the subtree rooted at x; null if no such key</span>
    <span class="kd">private</span> <span class="nc">Node</span> <span class="nf">max</span><span class="o">(</span><span class="nc">Node</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span> 
        <span class="c1">// assert x != null;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">x</span><span class="o">;</span> 
        <span class="k">else</span>                 <span class="k">return</span> <span class="nf">max</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">);</span> 
    <span class="o">}</span> 


    <span class="cm">/**
     * Returns the largest key in the symbol table less than or equal to {@code key}.
     * @param key the key
     * @return the largest key in the symbol table less than or equal to {@code key}
     * @throws NoSuchElementException if there is no such key
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */</span>
    <span class="kd">public</span> <span class="nc">Key</span> <span class="nf">floor</span><span class="o">(</span><span class="nc">Key</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">"argument to floor() is null"</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">isEmpty</span><span class="o">())</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">NoSuchElementException</span><span class="o">(</span><span class="s">"calls floor() with empty symbol table"</span><span class="o">);</span>
        <span class="nc">Node</span> <span class="n">x</span> <span class="o">=</span> <span class="n">floor</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">NoSuchElementException</span><span class="o">(</span><span class="s">"argument to floor() is too small"</span><span class="o">);</span>
        <span class="k">else</span>           <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="na">key</span><span class="o">;</span>
    <span class="o">}</span>    

    <span class="c1">// the largest key in the subtree rooted at x less than or equal to the given key</span>
    <span class="kd">private</span> <span class="nc">Node</span> <span class="nf">floor</span><span class="o">(</span><span class="nc">Node</span> <span class="n">x</span><span class="o">,</span> <span class="nc">Key</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">cmp</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">key</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">cmp</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">cmp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>  <span class="k">return</span> <span class="n">floor</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
        <span class="nc">Node</span> <span class="n">t</span> <span class="o">=</span> <span class="n">floor</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">t</span><span class="o">;</span> 
        <span class="k">else</span>           <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Returns the smallest key in the symbol table greater than or equal to {@code key}.
     * @param key the key
     * @return the smallest key in the symbol table greater than or equal to {@code key}
     * @throws NoSuchElementException if there is no such key
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */</span>
    <span class="kd">public</span> <span class="nc">Key</span> <span class="nf">ceiling</span><span class="o">(</span><span class="nc">Key</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">"argument to ceiling() is null"</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">isEmpty</span><span class="o">())</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">NoSuchElementException</span><span class="o">(</span><span class="s">"calls ceiling() with empty symbol table"</span><span class="o">);</span>
        <span class="nc">Node</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ceiling</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">NoSuchElementException</span><span class="o">(</span><span class="s">"argument to ceiling() is too small"</span><span class="o">);</span>
        <span class="k">else</span>           <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="na">key</span><span class="o">;</span>  
    <span class="o">}</span>

    <span class="c1">// the smallest key in the subtree rooted at x greater than or equal to the given key</span>
    <span class="kd">private</span> <span class="nc">Node</span> <span class="nf">ceiling</span><span class="o">(</span><span class="nc">Node</span> <span class="n">x</span><span class="o">,</span> <span class="nc">Key</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>  
        <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">cmp</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">key</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">cmp</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">cmp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>  <span class="k">return</span> <span class="n">ceiling</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
        <span class="nc">Node</span> <span class="n">t</span> <span class="o">=</span> <span class="n">ceiling</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">key</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">t</span><span class="o">;</span> 
        <span class="k">else</span>           <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Return the key in the symbol table of a given {@code rank}.
     * This key has the property that there are {@code rank} keys in
     * the symbol table that are smaller. In other words, this key is the
     * ({@code rank}+1)st smallest key in the symbol table.
     *
     * @param  rank the order statistic
     * @return the key in the symbol table of given {@code rank}
     * @throws IllegalArgumentException unless {@code rank} is between 0 and
     *        &lt;em&gt;n&lt;/em&gt;–1
     */</span>
    <span class="kd">public</span> <span class="nc">Key</span> <span class="nf">select</span><span class="o">(</span><span class="kt">int</span> <span class="n">rank</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">rank</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">rank</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"argument to select() is invalid: "</span> <span class="o">+</span> <span class="n">rank</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="nf">select</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">rank</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// Return key in BST rooted at x of given rank.</span>
    <span class="c1">// Precondition: rank is in legal range.</span>
    <span class="kd">private</span> <span class="nc">Key</span> <span class="nf">select</span><span class="o">(</span><span class="nc">Node</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">rank</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">leftSize</span> <span class="o">=</span> <span class="n">size</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
        <span class="k">if</span>      <span class="o">(</span><span class="n">leftSize</span> <span class="o">&gt;</span> <span class="n">rank</span><span class="o">)</span> <span class="k">return</span> <span class="n">select</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">,</span>  <span class="n">rank</span><span class="o">);</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">leftSize</span> <span class="o">&lt;</span> <span class="n">rank</span><span class="o">)</span> <span class="k">return</span> <span class="n">select</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">rank</span> <span class="o">-</span> <span class="n">leftSize</span> <span class="o">-</span> <span class="mi">1</span><span class="o">);</span> 
        <span class="k">else</span>                      <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="na">key</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Return the number of keys in the symbol table strictly less than {@code key}.
     * @param key the key
     * @return the number of keys in the symbol table strictly less than {@code key}
     * @throws IllegalArgumentException if {@code key} is {@code null}
     */</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">rank</span><span class="o">(</span><span class="nc">Key</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">key</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">"argument to rank() is null"</span><span class="o">);</span>
        <span class="k">return</span> <span class="nf">rank</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">root</span><span class="o">);</span>
    <span class="o">}</span> 

    <span class="c1">// number of keys less than key in the subtree rooted at x</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">rank</span><span class="o">(</span><span class="nc">Key</span> <span class="n">key</span><span class="o">,</span> <span class="nc">Node</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span> 
        <span class="kt">int</span> <span class="n">cmp</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">key</span><span class="o">);</span> 
        <span class="k">if</span>      <span class="o">(</span><span class="n">cmp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="n">rank</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">);</span> 
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">cmp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">size</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">+</span> <span class="n">rank</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">);</span> 
        <span class="k">else</span>              <span class="k">return</span> <span class="nf">size</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">);</span> 
    <span class="o">}</span> 

   <span class="cm">/***************************************************************************
    *  Range count and range search.
    ***************************************************************************/</span>

    <span class="cm">/**
     * Returns all keys in the symbol table as an {@code Iterable}.
     * To iterate over all of the keys in the symbol table named {@code st},
     * use the foreach notation: {@code for (Key key : st.keys())}.
     * @return all keys in the symbol table as an {@code Iterable}
     */</span>
    <span class="kd">public</span> <span class="nc">Iterable</span><span class="o">&lt;</span><span class="nc">Key</span><span class="o">&gt;</span> <span class="nf">keys</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">isEmpty</span><span class="o">())</span> <span class="k">return</span> <span class="k">new</span> <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Key</span><span class="o">&gt;();</span>
        <span class="k">return</span> <span class="nf">keys</span><span class="o">(</span><span class="n">min</span><span class="o">(),</span> <span class="n">max</span><span class="o">());</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Returns all keys in the symbol table in the given range,
     * as an {@code Iterable}.
     *
     * @param  lo minimum endpoint
     * @param  hi maximum endpoint
     * @return all keys in the symbol table between {@code lo} 
     *    (inclusive) and {@code hi} (inclusive) as an {@code Iterable}
     * @throws IllegalArgumentException if either {@code lo} or {@code hi}
     *    is {@code null}
     */</span>
    <span class="kd">public</span> <span class="nc">Iterable</span><span class="o">&lt;</span><span class="nc">Key</span><span class="o">&gt;</span> <span class="nf">keys</span><span class="o">(</span><span class="nc">Key</span> <span class="n">lo</span><span class="o">,</span> <span class="nc">Key</span> <span class="n">hi</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">lo</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">"first argument to keys() is null"</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">hi</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">"second argument to keys() is null"</span><span class="o">);</span>

        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Key</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Key</span><span class="o">&gt;();</span>
        <span class="c1">// if (isEmpty() || lo.compareTo(hi) &gt; 0) return queue;</span>
        <span class="n">keys</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">queue</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">hi</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">queue</span><span class="o">;</span>
    <span class="o">}</span> 

    <span class="c1">// add the keys between lo and hi in the subtree rooted at x</span>
    <span class="c1">// to the queue</span>
    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">keys</span><span class="o">(</span><span class="nc">Node</span> <span class="n">x</span><span class="o">,</span> <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Key</span><span class="o">&gt;</span> <span class="n">queue</span><span class="o">,</span> <span class="nc">Key</span> <span class="n">lo</span><span class="o">,</span> <span class="nc">Key</span> <span class="n">hi</span><span class="o">)</span> <span class="o">{</span> 
        <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span><span class="o">;</span> 
        <span class="kt">int</span> <span class="n">cmplo</span> <span class="o">=</span> <span class="n">lo</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">key</span><span class="o">);</span> 
        <span class="kt">int</span> <span class="n">cmphi</span> <span class="o">=</span> <span class="n">hi</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">key</span><span class="o">);</span> 
        <span class="k">if</span> <span class="o">(</span><span class="n">cmplo</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="n">keys</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">queue</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">hi</span><span class="o">);</span> 
        <span class="k">if</span> <span class="o">(</span><span class="n">cmplo</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">cmphi</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="n">queue</span><span class="o">.</span><span class="na">enqueue</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">key</span><span class="o">);</span> 
        <span class="k">if</span> <span class="o">(</span><span class="n">cmphi</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="n">keys</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">queue</span><span class="o">,</span> <span class="n">lo</span><span class="o">,</span> <span class="n">hi</span><span class="o">);</span> 
    <span class="o">}</span> 

    <span class="cm">/**
     * Returns the number of keys in the symbol table in the given range.
     *
     * @param  lo minimum endpoint
     * @param  hi maximum endpoint
     * @return the number of keys in the symbol table between {@code lo} 
     *    (inclusive) and {@code hi} (inclusive)
     * @throws IllegalArgumentException if either {@code lo} or {@code hi}
     *    is {@code null}
     */</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">size</span><span class="o">(</span><span class="nc">Key</span> <span class="n">lo</span><span class="o">,</span> <span class="nc">Key</span> <span class="n">hi</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">lo</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">"first argument to size() is null"</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">hi</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">"second argument to size() is null"</span><span class="o">);</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">lo</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">hi</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">contains</span><span class="o">(</span><span class="n">hi</span><span class="o">))</span> <span class="k">return</span> <span class="n">rank</span><span class="o">(</span><span class="n">hi</span><span class="o">)</span> <span class="o">-</span> <span class="n">rank</span><span class="o">(</span><span class="n">lo</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">else</span>              <span class="k">return</span> <span class="nf">rank</span><span class="o">(</span><span class="n">hi</span><span class="o">)</span> <span class="o">-</span> <span class="n">rank</span><span class="o">(</span><span class="n">lo</span><span class="o">);</span>
    <span class="o">}</span>


   <span class="cm">/***************************************************************************
    *  Check integrity of red-black tree data structure.
    ***************************************************************************/</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">check</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">isBST</span><span class="o">())</span>            <span class="nc">StdOut</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Not in symmetric order"</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">isSizeConsistent</span><span class="o">())</span> <span class="nc">StdOut</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Subtree counts not consistent"</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">isRankConsistent</span><span class="o">())</span> <span class="nc">StdOut</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Ranks not consistent"</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">is23</span><span class="o">())</span>             <span class="nc">StdOut</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Not a 2-3 tree"</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">isBalanced</span><span class="o">())</span>       <span class="nc">StdOut</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Not balanced"</span><span class="o">);</span>
        <span class="k">return</span> <span class="nf">isBST</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">isSizeConsistent</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">isRankConsistent</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">is23</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">isBalanced</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="c1">// does this binary tree satisfy symmetric order?</span>
    <span class="c1">// Note: this test also ensures that data structure is a binary tree since order is strict</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">isBST</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nf">isBST</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// is the tree rooted at x a BST with all keys strictly between min and max</span>
    <span class="c1">// (if min or max is null, treat as empty constraint)</span>
    <span class="c1">// Credit: Bob Dondero's elegant solution</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">isBST</span><span class="o">(</span><span class="nc">Node</span> <span class="n">x</span><span class="o">,</span> <span class="nc">Key</span> <span class="n">min</span><span class="o">,</span> <span class="nc">Key</span> <span class="n">max</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">min</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">x</span><span class="o">.</span><span class="na">key</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">min</span><span class="o">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">max</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">x</span><span class="o">.</span><span class="na">key</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">max</span><span class="o">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">return</span> <span class="nf">isBST</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">min</span><span class="o">,</span> <span class="n">x</span><span class="o">.</span><span class="na">key</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">isBST</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">x</span><span class="o">.</span><span class="na">key</span><span class="o">,</span> <span class="n">max</span><span class="o">);</span>
    <span class="o">}</span> 

    <span class="c1">// are the size fields correct?</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">isSizeConsistent</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">isSizeConsistent</span><span class="o">(</span><span class="n">root</span><span class="o">);</span> <span class="o">}</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">isSizeConsistent</span><span class="o">(</span><span class="nc">Node</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">size</span> <span class="o">!=</span> <span class="n">size</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">+</span> <span class="n">size</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">return</span> <span class="nf">isSizeConsistent</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">isSizeConsistent</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
    <span class="o">}</span> 

    <span class="c1">// check that ranks are consistent</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">isRankConsistent</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">rank</span><span class="o">(</span><span class="n">select</span><span class="o">(</span><span class="n">i</span><span class="o">)))</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">Key</span> <span class="n">key</span> <span class="o">:</span> <span class="n">keys</span><span class="o">())</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">select</span><span class="o">(</span><span class="n">rank</span><span class="o">(</span><span class="n">key</span><span class="o">)))</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// Does the tree have no red right links, and at most one (left)</span>
    <span class="c1">// red links in a row on any path?</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">is23</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">is23</span><span class="o">(</span><span class="n">root</span><span class="o">);</span> <span class="o">}</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">is23</span><span class="o">(</span><span class="nc">Node</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">isRed</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">))</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">!=</span> <span class="n">root</span> <span class="o">&amp;&amp;</span> <span class="n">isRed</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">isRed</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">))</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">return</span> <span class="nf">is23</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">is23</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
    <span class="o">}</span> 

    <span class="c1">// do all paths from root to leaf have same number of black edges?</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">isBalanced</span><span class="o">()</span> <span class="o">{</span> 
        <span class="kt">int</span> <span class="n">black</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>     <span class="c1">// number of black links on path from root to min</span>
        <span class="nc">Node</span> <span class="n">x</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">x</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">isRed</span><span class="o">(</span><span class="n">x</span><span class="o">))</span> <span class="n">black</span><span class="o">++;</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="nf">isBalanced</span><span class="o">(</span><span class="n">root</span><span class="o">,</span> <span class="n">black</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// does every path from the root to a leaf have the given number of black links?</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">isBalanced</span><span class="o">(</span><span class="nc">Node</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">black</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="n">black</span> <span class="o">==</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">isRed</span><span class="o">(</span><span class="n">x</span><span class="o">))</span> <span class="n">black</span><span class="o">--;</span>
        <span class="k">return</span> <span class="nf">isBalanced</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">left</span><span class="o">,</span> <span class="n">black</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">isBalanced</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="na">right</span><span class="o">,</span> <span class="n">black</span><span class="o">);</span>
    <span class="o">}</span> 


    <span class="cm">/**
     * Unit tests the {@code RedBlackBST} data type.
     *
     * @param args the command-line arguments
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span> 
        <span class="nc">RedBlackBST</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RedBlackBST</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="o">!</span><span class="nc">StdIn</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">key</span> <span class="o">=</span> <span class="nc">StdIn</span><span class="o">.</span><span class="na">readString</span><span class="o">();</span>
            <span class="n">st</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">StdOut</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
        <span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">s</span> <span class="o">:</span> <span class="n">st</span><span class="o">.</span><span class="na">keys</span><span class="o">())</span>
            <span class="nc">StdOut</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s</span> <span class="o">+</span> <span class="s">" "</span> <span class="o">+</span> <span class="n">st</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">s</span><span class="o">));</span>
        <span class="nc">StdOut</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
 
</code></pre></div></div>

</div>
  <div class="share-page">
  <span style="float: left;">Share this on &rarr;&nbsp;&nbsp;</span>

  <!-- Twitter -->
  <a href="https://twitter.com/share" class="twitter-share-button" data-via="github.io">Tweet</a>
  <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

  <!-- Facebook -->
  <div class="fb-share-button" data-href="https://clairedeng.github.io/data%20structure/tree/2020/04/11/Trees.html" data-layout="button_count" style="position: relative; top: -8px; left: 3px;"></div>
</div>

<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/sdk.js#xfbml=1&version=v2.6&appId=1749788565247320";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>

</div>


  
    
      
        
          
      
          
      
    
        
          
      
          
      
    
  
    
      
        
          
      
          
      
    
        
          
      
          
      
    
  
    
      
        
          
      
          
      
    
        
          
      
          
      
    
  
    
      
        
          
      
          
      
    
        
          
      
          
      
    
  
    
      
        
          
      
          
      
    
        
          
      
          
      
    
  
    
      
        
          
      
          
      
    
        
          
      
          
      
    
  
    
      
        
          
      
          
      
    
        
          
      
          
      
    
  
    
      
        
          
      
          
      
    
        
          
      
          
      
    
        
          
      
          
      
    
  
    
      
        
          
      
          
      
    
        
          
      
          
      
    
        
          
      
          
      
    
  
    
      
        
          
      
          
      
    
        
          
      
          
      
    
        
          
      
          
      
    
  
    
      
        
          
      
          
      
    
        
          
      
          
      
    
        
          
      
          
      
    
  
    
      
        
          
      
          
      
    
        
          
      
          
      
    
        
          
      
          
      
    
  
    
      
        
          
      
          
      
    
        
          
      
          
      
    
        
          
      
          
      
    
  
    
      
        
          
      
          
      
    
        
          
      
          
      
    
        
          
      
          
      
    
  
    
      
        
          
      
          
      
    
        
          
      
          
      
    
        
          
      
          
      
    
  
    
      
        
          
      
          
      
    
        
          
      
          
      
    
        
          
      
          
      
    
  
    
      
        
          
      
          
      
    
        
          
      
          
      
    
  
    
      
        
          
      
          
      
    
        
          
      
          
      
    
        
          
      
          
      
    
  
    
      
        
          
      
          
      
    
        
          
      
          
      
    
        
          
      
          
      
    
  
    
      
        
          
      
          
      
    
        
          
      
          
      
    
        
          
      
          
      
    
  
    
      
        
          
      
          
      
    
        
          
      
          
      
    
  
    
      
        
          
      
          
      
    
        
          
      
          
      
    
  
    
      
        
          
      
          
      
    
        
          
      
          
      
    
  
    
      
        
          
            
            <div class="panel-body">
              <h4>Related Posts</h4>
              <ul>
            
                <li class="relatedPost">
                  <a href="https://clairedeng.github.io/data%20structure/hash/2020/04/26/Hash.html">Hash</a>
                  
                    (Categories: <a href="/category/data structure">data structure</a>, <a href="/category/hash">hash</a>)
                  
                </li>
          
          
        
      
          
      
    
        
          
      
          
      
    
  
    
      
        
          
      
          
      
    
        
          
      
          
      
    
  
    
      
        
          
            
                <li class="relatedPost">
                  <a href="https://clairedeng.github.io/data%20structure/list/2020/04/11/Lists-Stacks-and-Queues.html">Lists, Stacks, and Queues</a>
                  
                    (Categories: <a href="/category/data structure">data structure</a>, <a href="/category/list">list</a>)
                  
                </li>
          
          
        
      
          
      
    
        
          
      
          
      
    
  
  
  </ul>
</div>


<div class="PageNavigation">
  
    <a class="prev" href="/data%20structure/list/2020/04/11/Lists-Stacks-and-Queues.html">&laquo; Lists, Stacks, and Queues</a>
  
  
    <a class="next" href="/data%20structure/hash/2020/04/26/Hash.html">Hash &raquo;</a>
  
</div>

<div class="disqus-comments">
  <div id="disqus_thread"></div>
  <script type="text/javascript">
    /* <![CDATA[ */
    var disqus_shortname = "stackproblems";
    var disqus_identifier = "https://clairedeng.github.io_Trees";
    var disqus_title = "Trees";

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    /* ]]> */
  </script>
</div>


        <footer>
          &copy; Claire Deng
          
            - <a href="https://github.com/clairedeng">https://github.com/clairedeng</a> - Powered by Jekyll.
          
          <div class="btn-github" style="float:right;">
            <iframe src="https://ghbtns.com/github-btn.html?user=clairedeng&repo=clairedeng.github.io&type=star&count=true" frameborder="0" scrolling="0" width="100" height="20px"></iframe>
            <iframe src="https://ghbtns.com/github-btn.html?user=clairedeng&repo=clairedeng.github.io&type=fork&count=true" frameborder="0" scrolling="0" width="100" height="20px"></iframe>
          </div>
        </footer>
      </div>
      <!-- end /.col-sm-8 -->
    </div>
    <!-- end /.container -->

    <!-- Bootstrap core JavaScript -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
    <script src="//code.jquery.com/jquery-migrate-1.2.1.min.js"></script>
    <script src="/static/js/bootstrap.min.js"></script>
    <script src="/static/js/super-search.js"></script>
    <script src="/static/js/thickbox-compressed.js"></script>
    <script src="/static/js/projects.js"></script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [['$','$'], ['\\(','\\)']],
          processEscapes: true
        }
      });
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
  </body>
</html>

